# 真实案例：从书法图像到机器人控制文件

## 📚 案例概述

这是一个真实的 CalliRewrite 转换案例，展示了汉字"昨"从图像到机器人控制点的完整数据流。

**源文件**: `rl_finetune/data/test_data/0.npy` + `0.png`
**目标**: 生成可在 Franka 机器人上执行的 NPZ 文件

---

## 🖼️ 输入：原始书法图像

**文件**: `0.png` (256×256 像素)

**字符**: "昨" (汉字，意为"昨天")

**特点**:
- 黑色笔画，白色背景
- 典型的书法风格
- 包含多个笔画（横、竖、撇、捺等）

---

## 📄 阶段1：RL 输出数据 (.npy)

**文件**: `0.npy`

### 数据结构
```python
形状: (27, 7)
格式: [p_t, x, y, r, col1, col2, col3]
```

### 前5行数据分析
```
索引  p_t   x      y      r      说明
-------------------------------------------
0     1.0   53.50  54.50  54.78  新笔画起点（第1笔）
1     0.0   53.50  54.50  54.78  继续画（相同位置）
2     0.0   66.07  78.41  68.59  移动到新位置
3     0.0   127.83 76.12  144.73 继续画（半径增大→压力增大）
4     1.0   110.08 158.07 118.02 新笔画起点（第2笔）
```

### 关键观察
- **27个控制点**: 表示整个字符的笔画序列
- **p_t标志**: 1表示新笔画起点，0表示连续点
- **虚拟坐标**: x, y, r 都在 [0, 255] 范围内
- **笔画半径**: r 值越大→笔画越粗→需要更大压力

---

## 🔄 阶段2：转换过程

### 转换参数
```python
alpha = 0.04      # 字符宽度 4cm
beta = 0.5        # 笔画宽度系数（正常）
style_type = 0    # 隶书风格（回锋起笔）
```

### 转换步骤详解

#### Step 1: 坐标归一化和缩放
```python
# 原始虚拟坐标
x_virtual = 53.50  (像素)
y_virtual = 54.50  (像素)
r_virtual = 54.78  (像素)

# 归一化到 [0, 1]
x_norm = 53.50 / 255 = 0.2098
y_norm = 54.50 / 255 = 0.2137
r_norm = 54.78 / 255 = 0.2148

# 缩放到真实尺寸
x_real = 0.2098 × 0.04 = 0.0084 m (8.4 mm)
y_real = 0.2137 × 0.04 = 0.0085 m (8.5 mm)
r_real = 0.2148 × 0.04 × 0.5 = 0.0043 m (4.3 mm)
```

#### Step 2: 半径转高度（校准函数）
```python
# 使用预校准的毛笔函数
r_real = 0.0043 m

# 查找分段线性函数
if r_real > 2.45866277e-03 and r_real < 0.0045:
    z = -2.37843574 × (r_real - 0.00246) - 0.00129
    z = -2.37843574 × (0.0043 - 0.00246) - 0.00129
    z = -2.37843574 × 0.00184 - 0.00129
    z = -0.00437 - 0.00129
    z = -0.00567 m

# 补偿工作台高度
z_final = -0.00567 - 0.09 = -0.0957 m
```

#### Step 3: 书法风格处理（隶书回锋）
```python
# 对于 p_t = 1 的起笔点
if p_t == 1:
    # 1. 从正上方悬停
    控制点1: (x, y, 0.05)  # 抬笔5cm

    # 2. 垂直下笔
    控制点2: (x, y, z)     # 下到纸面

    # 3. 回锋（向下一点方向的反方向移动）
    next_point = data[i+1]
    direction = (next_point - current_point) / norm
    控制点3: (x - 2r×dir_x, y - 2r×dir_y, z)

    # 4. 回到起点
    控制点4: (x, y, z)
```

---

## 📦 阶段3：输出 NPZ 文件

**文件**: `real_character_0.npz`

### 文件信息
```
大小: 1.73 KB
控制点数: 42 个
格式: {pos_3d_x, pos_3d_y, pos_3d_z}
```

### 坐标范围
```
X: [0.0084, 0.0317] m  →  范围 2.33 cm
Y: [0.0030, 0.0363] m  →  范围 3.33 cm
Z: [-0.0960, 0.0500] m →  范围 14.60 cm
```

### 前10个控制点
```
索引  X (m)    Y (m)    Z (m)     状态    说明
-------------------------------------------------
0    0.0084   0.0085   0.0500    抬笔    第1笔：悬停
1    0.0084   0.0085  -0.0957    接触    下笔接触
2    0.0084   0.0085  -0.0957    接触    回锋点1
3    0.0104   0.0123  -0.0960    接触    继续画
4    0.0201   0.0119  -0.0960    接触    笔画主体
5    0.0173   0.0248   0.0500    抬笔    第2笔：悬停
6    0.0173   0.0248  -0.0960    接触    下笔
7    0.0173   0.0248  -0.0960    接触    回锋点
8    0.0265   0.0253   0.0500    抬笔    第3笔：悬停
9    0.0265   0.0253  -0.0960    接触    下笔
```

### 最后5个控制点（渐进抬笔）
```
索引  X (m)    Y (m)    Z (m)     状态
-----------------------------------------
37   0.0184   0.0149  -0.0810    接触
38   0.0184   0.0149  -0.0660    接触
39   0.0184   0.0149  -0.0510    接触
40   0.0184   0.0149  -0.0360    接触
41   0.0184   0.0149  -0.0210    接触
```
注意 Z 轴逐渐增大（从 -0.081 到 -0.021），实现平滑抬笔，防止甩墨。

---

## 📊 数据统计分析

### 转换效果
```
原始控制点 (npy):  27 个
转换后控制点 (npz): 42 个

增加原因：
- 每个起笔点 (p_t=1) 增加 3-4 个点（抬笔→下笔→回锋）
- 末尾增加 5 个渐进抬笔点
```

### 笔画分析
```
估计笔画数: 根据 p_t=1 的数量
抬笔点数: 10 个 (Z > 0)
接触点数: 32 个 (Z ≤ 0)

抬笔/接触比例: 10/32 ≈ 31%
```

### Z 轴分布
```
抬笔区域:    Z = 0.05 m        (5cm 高悬停)
纸面参考:    Z = 0.00 m        (参考平面)
工作台:      Z = -0.09 m       (纸面实际位置)
轻触:        Z ≈ -0.091 m      (轻微接触)
正常压力:    Z ≈ -0.093 ~ -0.095 m
重压:        Z ≈ -0.096 m      (最大压力)
```

---

## 🎨 可视化对比

### 原始图像 (0.png)
- 256×256 像素
- 黑色笔画
- 书法字"昨"

### RL 优化序列 (0.npy)
- 27个控制点
- 虚拟坐标 [0-255]
- 包含笔画半径信息

### 机器人控制 (real_character_0.npz)
- 42个3D控制点
- 真实坐标 (米)
- 包含抬笔/压力信息

---

## 🤖 在机器人上执行

### 使用 RoboControl.py
```bash
python RoboControl.py \
    ./examples/real_character_0.npz \
    172.16.0.2 \
    0.05
```

### 执行流程
```
1. 连接 Franka 机器人
2. 移动到工作空间中心上方
3. 逐点执行轨迹:
   点0:  移动到 (8.4mm, 8.5mm, 50mm)   抬笔
   点1:  下降到 (8.4mm, 8.5mm, -95.7mm) 接触纸面
   点2:  保持接触，画出笔画
   ...
4. 完成后返回安全位置
```

### 预期结果
- 在纸面上重现"昨"字
- 字符宽度约 2.3cm
- 字符高度约 3.3cm
- 笔画粗细随压力变化

---

## 🔍 转换质量检查

### ✅ 检查项
- [x] 坐标范围合理 (< 5cm)
- [x] Z 轴范围正常 (-0.1m ~ 0.05m)
- [x] 抬笔点充足 (避免拖笔)
- [x] 笔画连续性 (同一笔画内 Z 值稳定)
- [x] 渐进抬笔 (最后5个点 Z 递增)

### ⚠️ 注意事项
1. **工作台高度**: Z = -0.09m 需要根据实际调整
2. **字符大小**: alpha = 0.04 可以调整 (0.03-0.08)
3. **笔画粗细**: beta = 0.5 可以调整 (0.3-1.0)
4. **书法风格**: style_type 可以切换隶书/楷书

---

## 💡 关键转换公式总结

### 坐标转换
```python
x_real = (x_virtual / 255) × alpha
y_real = (y_virtual / 255) × alpha
r_real = (r_virtual / 255) × alpha × beta
```

### 高度转换（校准函数）
```python
z = func_brush(r_real)
z_robot = z - 0.09  # 工作台补偿
```

### 完整转换
```python
虚拟 RL 数据 (.npy)
    [p_t, x∈[0,255], y∈[0,255], r∈[0,255]]
    ↓ 归一化 + 缩放
    [p_t, x_real, y_real, r_real] (米)
    ↓ 校准函数
    [p_t, x_real, y_real, z_real] (米)
    ↓ 书法风格处理
机器人控制 (.npz)
    {pos_3d_x[], pos_3d_y[], pos_3d_z[]}
```

---

## 📚 相关文件

| 文件 | 路径 | 说明 |
|------|------|------|
| 原始图像 | `rl_finetune/data/test_data/0.png` | 书法字"昨" |
| RL输出 | `rl_finetune/data/test_data/0.npy` | 虚拟笔画序列 |
| 机器人控制 | `callibrate/examples/real_character_0.npz` | 真实3D坐标 |
| 转换脚本 | `callibrate/calibrate.py` | `convert_rl_to_npz()` |
| 执行脚本 | `callibrate/RoboControl.py` | `Control()` |

---

**案例总结**: 这个真实案例展示了 CalliRewrite 如何将一个 256×256 的书法图像通过多阶段处理，最终转换为42个精确的3D机器人控制点，实现了从像素到物理空间的完美映射！
